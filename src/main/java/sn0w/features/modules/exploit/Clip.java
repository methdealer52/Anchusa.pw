package sn0w.features.modules.exploit;
import sn0w.features.modules.Module;
import sn0w.features.setting.*;
import net.minecraft.network.play.client.*;
import net.minecraft.network.*;
import net.minecraft.util.math.*;
import net.minecraft.init.*;
import net.minecraft.block.*;
import org.apache.commons.lang3.builder.*;

public class Clip extends Module
{
    Setting<Integer> clipAmount;
    Setting<Integer> clipStep;
    int disable;

    public Clip() {
    super("Clip","Makes you clipped in a corner" , Category.EXPLOIT, true, false, false);
        this.clipAmount = (Setting<Integer>)this.register(new Setting("Amount", 6, 1, 6));
        this.clipStep = (Setting<Integer>)this.register(new Setting("Step", 3, 1, 6));
        this.disable = 0;
    }

    @Override
    public void onUpdate() {
        if (fullNullCheck()) {
            return 0;
        }
        final Vec2i dir = this.getWallDir();
        if (dir == null) {
            this.disable();
            return 0;
        }
        final double amt = this.clipAmount.getValue(true) * 0.01 - 0.001;
        final BlockPos pos = this.getFlooredPos();
        final Vec3d center = new Vec3d(pos.getX() + 0.5 + 0.2 * dir.x, (double)pos.getY(), pos.getZ() + 0.5 + 0.2 * dir.y);
        Vec3d target = new Vec3d(center.x + amt * dir.x, center.y, center.z + amt * dir.y);
        final double x = Math.abs(target.x - Clip.mc.player.posX);
        final double z = Math.abs(target.z - Clip.mc.player.posZ);
        if (x <= amt + 0.01 && z <= amt + 0.01) {
            Clip.mc.player.setVelocity(0.0, 0.0, 0.0);
            if (x <= amt + 0.001 && z <= amt + 0.001) {
                if (x <= 0.001 && z <= 0.001) {
                    if (this.disable > 5) {
                        this.disable();
                    }
                    else {
                        ++this.disable;
                    }
                    return 0;
                }
                this.disable = 0;
                final double mx = Math.abs(Math.max(0.0, amt - x) + this.clipStep.getValue(true) * 0.01);
                final double mz = Math.abs(Math.max(0.0, amt - z) + this.clipStep.getValue(true) * 0.01);
                target = new Vec3d(center.x + dir.x * Math.min(mx, amt), center.y, center.z + dir.y * Math.min(mz, amt));
                Clip.mc.player.setPosition(target.x, target.y, target.z);
                Clip.mc.getConnection().sendPacket((Packet)new CPacketPlayer.Position(Clip.mc.player.posX, Clip.mc.player.posY, Clip.mc.player.posZ, Clip.mc.player.onGround));
                Clip.mc.getConnection().sendPacket((Packet)new CPacketPlayer.Position(Clip.mc.player.posX + 0.1 * dir.y, Clip.mc.player.posY, Clip.mc.player.posZ + 0.1 * dir.y, Clip.mc.player.onGround));
            }
            else {
                final double mx = center.x - Clip.mc.player.posX;
                final double mz = center.z - Clip.mc.player.posZ;
                Clip.mc.player.motionX = mx / 3.0;
                Clip.mc.player.motionZ = mz / 3.0;
            }
        }
        return 0;
    }

    int getBlocks(final Vec2i vec2i) {
        int i = 0;
        final BlockPos pos = this.getFlooredPos();
        if (vec2i.x != 0) {
            if (!this.isBlockHard(pos.add(vec2i.x, 0, 0))) {
                return 0;
            }
            ++i;
        }
        if (vec2i.y != 0) {
            if (!this.isBlockHard(pos.add(0, 0, vec2i.y))) {
                return 0;
            }
            ++i;
        }
        return i;
    }

    boolean isBlockHard(final BlockPos pos) {
        final Block b = Clip.mc.world.getBlockState(pos).getBlock();
        return b == Blocks.BEDROCK || b == Blocks.OBSIDIAN || b == Blocks.ENDER_CHEST;
    }

    Vec2i getWallDir() {
        final Vec2i[] vecs = { new Vec2i(1, 1), new Vec2i(1, -1), new Vec2i(-1, -1), new Vec2i(-1, 1), new Vec2i(0, 1), new Vec2i(0, -1), new Vec2i(1, 0), new Vec2i(-1, 0) };
        final BlockPos pos = this.getFlooredPos();
        double bestv = 0.0;
        Vec2i best = null;
        for (final Vec2i vec2i : vecs) {
            final double v = this.getBlocks(vec2i) * 10 - Clip.mc.player.getDistance(pos.getX() + 0.5 + vec2i.x, Clip.mc.player.posY, pos.getZ() + 0.5 + vec2i.y);
            if (v > bestv) {
                bestv = v;
                best = vec2i;
            }
        }
        return best;
    }

    BlockPos getFlooredPos() {
        return new BlockPos(Math.floor(Clip.mc.player.posX), Math.floor(Clip.mc.player.posY + 0.2), Math.floor(Clip.mc.player.posZ));
    }

    class Vec2i
    {
        public final int x;
        public final int y;

        public Vec2i(final int inX, final int inY) {
            this.x = inX;
            this.y = inY;
        }

        @Override
        public String toString() {
            return "Vec2i(" + this.x + "," + this.y + ")";
        }

        @Override
        public boolean equals(final Object p_equals_1_) {
            if (this == p_equals_1_) {
                return true;
            }
            if (!(p_equals_1_ instanceof Vec2i)) {
                return false;
            }
            final Vec2i vec3i = (Vec2i)p_equals_1_;
            return this.x == vec3i.x && this.y == vec3i.y;
        }

        @Override
        public int hashCode() {
            return new HashCodeBuilder(17, 31).append(this.x).append(this.y).toHashCode();
        }
    }
}
